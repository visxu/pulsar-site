"use strict";(self.webpackChunkwebsite_next=self.webpackChunkwebsite_next||[]).push([[51140],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>b});var n=a(67294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var i=n.createContext({}),d=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},u=function(e){var t=d(e.components);return n.createElement(i.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,r=e.originalType,i=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),p=d(a),h=l,b=p["".concat(i,".").concat(h)]||p[h]||c[h]||r;return a?n.createElement(b,s(s({ref:t},u),{},{components:a})):n.createElement(b,s({ref:t},u))}));function b(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=a.length,s=new Array(r);s[0]=h;var o={};for(var i in t)hasOwnProperty.call(t,i)&&(o[i]=t[i]);o.originalType=e,o[p]="string"==typeof e?e:l,s[1]=o;for(var d=2;d<r;d++)s[d]=a[d];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},85162:(e,t,a)=>{a.d(t,{Z:()=>s});var n=a(67294),l=a(86010);const r={tabItem:"tabItem_Ymn6"};function s(e){let{children:t,hidden:a,className:s}=e;return n.createElement("div",{role:"tabpanel",className:(0,l.Z)(r.tabItem,s),hidden:a},t)}},74866:(e,t,a)=>{a.d(t,{Z:()=>y});var n=a(87462),l=a(67294),r=a(86010),s=a(12466),o=a(16550),i=a(91980),d=a(67392),u=a(50012);function p(e){return function(e){return l.Children.map(e,(e=>{if(!e||(0,l.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:l}}=e;return{value:t,label:a,attributes:n,default:l}}))}function c(e){const{values:t,children:a}=e;return(0,l.useMemo)((()=>{const e=t??p(a);return function(e){const t=(0,d.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function h(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function b(e){let{queryString:t=!1,groupId:a}=e;const n=(0,o.k6)(),r=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,i._X)(r),(0,l.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(n.location.search);t.set(r,e),n.replace({...n.location,search:t.toString()})}),[r,n])]}function m(e){const{defaultValue:t,queryString:a=!1,groupId:n}=e,r=c(e),[s,o]=(0,l.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!h({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:r}))),[i,d]=b({queryString:a,groupId:n}),[p,m]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,r]=(0,u.Nk)(a);return[n,(0,l.useCallback)((e=>{a&&r.set(e)}),[a,r])]}({groupId:n}),k=(()=>{const e=i??p;return h({value:e,tabValues:r})?e:null})();(0,l.useLayoutEffect)((()=>{k&&o(k)}),[k]);return{selectedValue:s,selectValue:(0,l.useCallback)((e=>{if(!h({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);o(e),d(e),m(e)}),[d,m,r]),tabValues:r}}var k=a(72389);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function f(e){let{className:t,block:a,selectedValue:o,selectValue:i,tabValues:d}=e;const u=[],{blockElementScrollPositionUntilNextRender:p}=(0,s.o5)(),c=e=>{const t=e.currentTarget,a=u.indexOf(t),n=d[a].value;n!==o&&(p(t),i(n))},h=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const a=u.indexOf(e.currentTarget)+1;t=u[a]??u[0];break}case"ArrowLeft":{const a=u.indexOf(e.currentTarget)-1;t=u[a]??u[u.length-1];break}}t?.focus()};return l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":a},t)},d.map((e=>{let{value:t,label:a,attributes:s}=e;return l.createElement("li",(0,n.Z)({role:"tab",tabIndex:o===t?0:-1,"aria-selected":o===t,key:t,ref:e=>u.push(e),onKeyDown:h,onClick:c},s,{className:(0,r.Z)("tabs__item",g.tabItem,s?.className,{"tabs__item--active":o===t})}),a??t)})))}function N(e){let{lazy:t,children:a,selectedValue:n}=e;const r=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=r.find((e=>e.props.value===n));return e?(0,l.cloneElement)(e,{className:"margin-top--md"}):null}return l.createElement("div",{className:"margin-top--md"},r.map(((e,t)=>(0,l.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function v(e){const t=m(e);return l.createElement("div",{className:(0,r.Z)("tabs-container",g.tabList)},l.createElement(f,(0,n.Z)({},e,t)),l.createElement(N,(0,n.Z)({},e,t)))}function y(e){const t=(0,k.Z)();return l.createElement(v,(0,n.Z)({key:String(t)},e))}},63028:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>b,frontMatter:()=>o,metadata:()=>d,toc:()=>p});var n=a(87462),l=(a(67294),a(3905)),r=a(74866),s=a(85162);const o={id:"concepts-broker-load-balancing-concepts",title:"Concepts",sidebar_label:"Concepts"},i=void 0,d={unversionedId:"concepts-broker-load-balancing-concepts",id:"version-3.1.x/concepts-broker-load-balancing-concepts",title:"Concepts",description:"Pulsar provides robust support for load balancing to ensure efficient utilization of resources across Pulsar clusters. Load balancing in Pulsar involves distributing messages and partitions evenly among brokers and consumers to prevent hotspots and optimize performance.",source:"@site/versioned_docs/version-3.1.x/concepts-broker-load-balancing-concepts.md",sourceDirName:".",slug:"/concepts-broker-load-balancing-concepts",permalink:"/docs/3.1.x/concepts-broker-load-balancing-concepts",draft:!1,editUrl:"https://github.com/apache/pulsar-site/edit/main/versioned_docs/version-3.1.x/concepts-broker-load-balancing-concepts.md",tags:[],version:"3.1.x",frontMatter:{id:"concepts-broker-load-balancing-concepts",title:"Concepts",sidebar_label:"Concepts"},sidebar:"docsSidebar",previous:{title:"Benefits",permalink:"/docs/3.1.x/concepts-broker-load-balancing-benefits"},next:{title:"Types",permalink:"/docs/3.1.x/concepts-broker-load-balancing-types"}},u={},p=[{value:"Brokers",id:"brokers",level:2},{value:"Producers",id:"producers",level:2},{value:"Consumers",id:"consumers",level:2},{value:"Topics",id:"topics",level:2},{value:"Bundles",id:"bundles",level:2},{value:"Broker load balancing",id:"broker-load-balancing",level:2},{value:"Topic bundling",id:"topic-bundling",level:2},{value:"Workflow",id:"workflow",level:3},{value:"Step 1: shard namespaces into bundles",id:"step-1-shard-namespaces-into-bundles",level:4},{value:"Step 2: assign topics to bundles",id:"step-2-assign-topics-to-bundles",level:4},{value:"Bundle assignment",id:"bundle-assignment",level:2},{value:"Workflow",id:"workflow-1",level:3},{value:"Step 1: assign bundles to brokers dynamically",id:"step-1-assign-bundles-to-brokers-dynamically",level:4},{value:"Step 2: reassign bundles to other brokers (optional)",id:"step-2-reassign-bundles-to-other-brokers-optional",level:4},{value:"Bundle splitting",id:"bundle-splitting",level:2},{value:"Workflow",id:"workflow-2",level:3},{value:"Step 1: find target bundles",id:"step-1-find-target-bundles",level:4},{value:"Step 2: compute bundle splitting boundaries",id:"step-2-compute-bundle-splitting-boundaries",level:4},{value:"Step 3: split bundles by boundaries",id:"step-3-split-bundles-by-boundaries",level:4},{value:"Step 1: find target bundles",id:"step-1-find-target-bundles-1",level:4},{value:"Step 2: compute bundle splitting position boundaries",id:"step-2-compute-bundle-splitting-position-boundaries",level:4},{value:"Bundle splitting algorithms",id:"bundle-splitting-algorithms",level:3},{value:"range_equally_divide",id:"range_equally_divide",level:4},{value:"topic_count_equally_divide",id:"topic_count_equally_divide",level:4},{value:"specified_positions_divide",id:"specified_positions_divide",level:4},{value:"flow_or_qps_equally_divide",id:"flow_or_qps_equally_divide",level:4},{value:"Case 1: split position is determined by message rate as it reaches the threshold earlier",id:"case-1-split-position-is-determined-by-message-rate-as-it-reaches-the-threshold-earlier",level:5},{value:"Case 2: split position is determined by message throughput as it reaches the threshold earlier",id:"case-2-split-position-is-determined-by-message-throughput-as-it-reaches-the-threshold-earlier",level:4},{value:"Case 3: split position is determined by both message rate and message throughput as they reach the thresholds at the same time",id:"case-3-split-position-is-determined-by-both-message-rate-and-message-throughput-as-they-reach-the-thresholds-at-the-same-time",level:4},{value:"Bundle unloading",id:"bundle-unloading",level:2},{value:"Workflow",id:"workflow-3",level:3},{value:"Step 1: find target brokers",id:"step-1-find-target-brokers",level:4},{value:"Step 2: unload bundles",id:"step-2-unload-bundles",level:4},{value:"Step 3: assign new owners",id:"step-3-assign-new-owners",level:4},{value:"Step 1: find target bundles",id:"step-1-find-target-bundles-2",level:4},{value:"Step 2: unload hot bundles",id:"step-2-unload-hot-bundles",level:4},{value:"Bundle unloading strategies",id:"bundle-unloading-strategies",level:3},{value:"OverloadShedder",id:"overloadshedder",level:4},{value:"ThresholdShedder",id:"thresholdshedder",level:4},{value:"Workflow",id:"workflow-4",level:5},{value:"UniformLoadShedder",id:"uniformloadshedder",level:4},{value:"TransferShedder",id:"transfershedder",level:4},{value:"Related topics",id:"related-topics",level:2}],c={toc:p},h="wrapper";function b(e){let{components:t,...o}=e;return(0,l.kt)(h,(0,n.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Pulsar provides robust support for load balancing to ensure efficient utilization of resources across Pulsar clusters. Load balancing in Pulsar involves distributing messages and partitions evenly among brokers and consumers to prevent hotspots and optimize performance."),(0,l.kt)("p",null,"Before getting started with load balancing, it's important to review the key components to ensure that resources are utilized efficiently and varying workloads can be handled by the system effectively."),(0,l.kt)("h2",{id:"brokers"},"Brokers"),(0,l.kt)("p",null,"In a Pulsar cluster, ",(0,l.kt)("a",{parentName:"p",href:"/docs/3.1.x/reference-terminology#broker"},"brokers")," are responsible for serving messages for different topics and partitions. Broker load balancing ensures that each broker handles a proportional share of the load. "),(0,l.kt)("h2",{id:"producers"},"Producers"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"/docs/3.1.x/reference-terminology#producer"},"Producers")," in Pulsar are responsible for publishing messages to topics. Pulsar clients (producers) connect to brokers to publish messages. Producer load balancing (i.e., connection pooling mechanism in Pulsar) ensures that producers are distributed across brokers to avoid overwhelming a single broker with too many connections."),(0,l.kt)("h2",{id:"consumers"},"Consumers"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"/docs/3.1.x/reference-terminology#consumer"},"Consumers")," in Pulsar are responsible for consuming messages from topics. Depending on how consumer load balancing is configured (i.e., using exclusive or shared consumers or auto-rebalancing), you can ensure even load distribution."),(0,l.kt)("h2",{id:"topics"},"Topics"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"/docs/3.1.x/reference-terminology#topic"},"Topics")," are the basic units for clients to publish and consume messages. Related topics are logically grouped into a namespace. To efficiently manage metadata and keep track of all of them moving through the system, Pulsar uses a strategy of grouping topics by partitioning on a namespace to create topic bundles."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Relationships of topics and namespaces",src:a(84865).Z,width:"578",height:"290"})),(0,l.kt)("h2",{id:"bundles"},"Bundles"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"/docs/3.1.x/reference-terminology#namespace-bundle"},"Bundles")," represent a range of partitions for a particular namespace in Pulsar, comprising a portion of the overall hash range of the namespace. "),(0,l.kt)("p",null,"Bundle is introduced in Pulsar to represent a middle-layer group. Each bundle is an ",(0,l.kt)("strong",{parentName:"p"},"assignment unit"),", which means topics are assigned to brokers at the ",(0,l.kt)("strong",{parentName:"p"},"bundle")," level rather than the topic level."),(0,l.kt)("h2",{id:"broker-load-balancing"},"Broker load balancing"),(0,l.kt)("p",null,'The broker load balancer component is like a "traffic cop" sitting between clients and brokers. It balances topic sessions across brokers based on dynamic load data, such as broker resource usage (e.g., CPU, memory, network IO) and topic/bundle loads (e.g., throughput).'),(0,l.kt)("p",null,"When properly balanced, the brokers can handle increased traffic and ensure that the system can scale seamlessly to accommodate growing workloads. Load balancing helps prevent bottlenecks and ensures that the resources of the cluster are utilized optimally, leading to better throughput and reduced message processing latency."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Concept of broker load balancer",src:a(68933).Z,width:"1064",height:"646"})),(0,l.kt)("h2",{id:"topic-bundling"},"Topic bundling"),(0,l.kt)("p",null,"Topic bundling refers to the process of grouping topics into bundles. Pulsar organizes topics into bundles within a namespace. Each bundle is a range of partitions, and Pulsar can automatically distribute these bundles across brokers to achieve load balancing. This allows the cluster to scale more efficiently as brokers can independently manage their assigned bundles."),(0,l.kt)("p",null,"For example, "),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Topic load statistics (e.g., message rates) are aggregated at the ",(0,l.kt)("strong",{parentName:"p"},"bundle")," layer, which reduces the cardinality of load samples to monitor.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"For dynamic topic-broker assignments, Pulsar persists these mappings at the ",(0,l.kt)("strong",{parentName:"p"},"bundle"),"level, which decreases the space for storing dynamic topic-broker ownerships."))),(0,l.kt)("p",null,"Pulsar allows you to dynamically scale the number of brokers, producers, and consumers to adapt to changing workloads. As brokers are added or removed, Pulsar handles the redistribution of partitions and bundles automatically."),(0,l.kt)("h3",{id:"workflow"},"Workflow"),(0,l.kt)("p",null,"Below is the workflow for grouping topics into bundles."),(0,l.kt)("h4",{id:"step-1-shard-namespaces-into-bundles"},"Step 1: shard namespaces into bundles"),(0,l.kt)("p",null,"Internally, when a namespace is created, the namespace is sharded into a list of bundles. "),(0,l.kt)("h4",{id:"step-2-assign-topics-to-bundles"},"Step 2: assign topics to bundles"),(0,l.kt)("p",null,'When a topic is created or looked up for pub/sub sessions, brokers map the topic to a particular bundle by taking the hash of the topic name (for example,  hash("my-topic") = 0x0000000F) and checking in which bundle the hash falls. '),(0,l.kt)("p",null,'Here "topic" means either a ',(0,l.kt)("strong",{parentName:"p"},"non-partitioned topic")," or ",(0,l.kt)("strong",{parentName:"p"},"one partition of a partitioned topic"),". For partitioned topics, Pulsar internally considers partitions as separate topics, hence different partitions can be assigned to different bundles and brokers. "),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Workflow of topic bundling",src:a(2681).Z,width:"1066",height:"528"})),(0,l.kt)("h2",{id:"bundle-assignment"},"Bundle assignment"),(0,l.kt)("p",null,"Bundle assignment refers to assigning bundles to brokers dynamically based on changing conditions. "),(0,l.kt)("p",null,"For example, based on broker resource usage (e.g., CPU, memory, network IO) and bundle loads (e.g., throughput), a bundle is dynamically assigned to a particular broker. Each bundle is independent of the others and thus is independently assigned to different brokers. Each broker takes ownership of a bundle (aka, a subset of the topics for a namespace)."),(0,l.kt)("p",null,"Bundle assignment plays a crucial role in achieving efficient load distribution and scalability within a Pulsar cluster. The purpose of bundle assignments is to ensure balanced resource utilization and facilitate dynamic scaling within the Pulsar architecture."),(0,l.kt)("h3",{id:"workflow-1"},"Workflow"),(0,l.kt)("p",null,"Below is the workflow for dynamic bundle assignment."),(0,l.kt)("h4",{id:"step-1-assign-bundles-to-brokers-dynamically"},"Step 1: assign bundles to brokers dynamically"),(0,l.kt)("p",null,"When a client starts using new topics (bundles) that are not assigned to any broker, a process is triggered to choose the best-suited broker to acquire ownership of these bundles according to the load conditions."),(0,l.kt)("h4",{id:"step-2-reassign-bundles-to-other-brokers-optional"},"Step 2: reassign bundles to other brokers (optional)"),(0,l.kt)("p",null,"If a broker owning a bundle crashes, the bundle (topic) is reassigned to another available broker."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Workflow of dynamic bundle assignment",src:a(22451).Z,width:"936",height:"714"})),(0,l.kt)("p",null,"To discover the current bundle-broker ownership for a given topic, Pulsar uses a server-side discovery mechanism that redirects clients to the owner brokers' URLs. This discovery logic requires:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Bundle key ranges for a given namespace, to map a topic to a bundle.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Bundle-broker ownership mapping, to direct the client to the current owner or to trigger a new ownership acquisition in case there is no broker assigned.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"All bundle ranges and broker-bundle ownership mappings are stored in a metadata space, and brokers look up them when clients try to discover owner brokers. For performance reasons, these data are cached at the broker in-memory layer too."))),(0,l.kt)("h2",{id:"bundle-splitting"},"Bundle splitting"),(0,l.kt)("p",null,"Bundle splitting refers to the process of identifying and splitting overloaded bundles, which helps reduce hot spots, achieve more granular load balancing, improve resource utilization, and enable finer-grained horizontal scaling within the Pulsar cluster."),(0,l.kt)("p",null,"The bundle splitting process involves breaking down the original bundle into smaller bundles, each containing a subset of the original partitions. This allows for better distribution of the message and processing load across brokers in the cluster."),(0,l.kt)("p",null,"You can split bundles in the following ways:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Automatic: enable Pulsar's automatic bundle splitting process when a namespace has a significant increase in workload or the number of partitions exceeds the optimal capacity for a single bundle.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Manual: trigger bundle splitting manually, to divide an existing bundle into multiple smaller bundles. "))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Bundle splitting methods"),(0,l.kt)("th",{parentName:"tr",align:null},"Definition"),(0,l.kt)("th",{parentName:"tr",align:null},"When to use"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Automatic"),(0,l.kt)("td",{parentName:"tr",align:null},"Bundles are split automatically based on different ",(0,l.kt)("a",{parentName:"td",href:"#bundle-splitting-algorithms"},"bundle splitting algorithms"),"."),(0,l.kt)("td",{parentName:"tr",align:null},"Automatic bundle splitting is most commonly used.",(0,l.kt)("br",null),(0,l.kt)("br",null),"You can use this method in various scenarios, such as when a bundle remains hot for a long time.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Manual"),(0,l.kt)("td",{parentName:"tr",align:null},"Bundles are split manually based on specified positions."),(0,l.kt)("td",{parentName:"tr",align:null},"Manual bundle splitting serves as a supplementary approach to automatic bundle splitting.",(0,l.kt)("br",null),(0,l.kt)("br",null),"You can use this method in various scenarios, such as: ",(0,l.kt)("br",null),(0,l.kt)("br",null)," - If automatic bundle splitting is enabled, but there are still bundles that remain hot for a long time. ",(0,l.kt)("br",null),(0,l.kt)("br",null)," - If you want to split bundles and redistribute traffic evenly before having any broker overloaded.")))),(0,l.kt)("h3",{id:"workflow-2"},"Workflow"),(0,l.kt)("p",null,"Below is the workflow for splitting bundles automatically or manually."),(0,l.kt)(r.Z,{groupId:"bundle-splitting-workflow",defaultValue:"Automatic bundle splitting",values:[{label:"Automatic bundle splitting",value:"Automatic bundle splitting"},{label:"Manual bundle splitting",value:"Manual bundle splitting"}],mdxType:"Tabs"},(0,l.kt)(s.Z,{value:"Automatic bundle splitting",mdxType:"TabItem"},(0,l.kt)("h4",{id:"step-1-find-target-bundles"},"Step 1: find target bundles"),(0,l.kt)("p",null,"If the auto bundle split is enabled, "),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"For the modular load balancer, the leader broker will check if any bundle's load is beyond the threshold.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"For the extensible load balancer, the load manager will check the bundle's load in each owner broker."))),(0,l.kt)("p",null,"Bundle splitting threshold can be set based on various conditions. Any existing bundle that exceeds any of the thresholds is a candidate to be split. The load balancer assigns the newly split bundles to other brokers, to facilitate the traffic distribution."),(0,l.kt)("p",null,"For how to enable bundle split and set bundle split thresholds automatically, see TBD (the docs is WIP, stay tuned!)."),(0,l.kt)("h4",{id:"step-2-compute-bundle-splitting-boundaries"},"Step 2: compute bundle splitting boundaries"),(0,l.kt)("p",null,"Now the target bundles which need to be split are found. Before splitting, the owner broker needs to compute the splitting positions based on ",(0,l.kt)("a",{parentName:"p",href:"#bundle-splitting-algorithms"},"bundle splitting algorithms"),". "),(0,l.kt)("h4",{id:"step-3-split-bundles-by-boundaries"},"Step 3: split bundles by boundaries"),(0,l.kt)("p",null,"Now the owner broker starts splitting the target bundles and then repartition them.  "),(0,l.kt)("p",null,"After the split, the owner broker updates the bundle ownerships and ranges in the metadata space. The newly split bundles can be automatically unloaded from the owner broker."),(0,l.kt)("p",null,"For example, if the bundle partition is ","[0x0000, 0x8000, 0xFFFF]",", and the splitting boundary is ","[0x4000]"," on the target bundle range, [0x0000, 0x8000)."),(0,l.kt)("p",null,"Then the bundle partitions after split is ","[0x0000, 0x4000, 0x8000, 0xFFFF]","."),(0,l.kt)("p",null,"Then the bundle ranges after split is [0x0000, 0x4000), [0x4000, 0x8000), and ","[0x8000, 0xFFFF]",".")),(0,l.kt)(s.Z,{value:"Manual bundle splitting",mdxType:"TabItem"},(0,l.kt)("h4",{id:"step-1-find-target-bundles-1"},"Step 1: find target bundles"),(0,l.kt)("p",null,"Based on the broker resource usage (for example, the number of topics or sessions, message rates, or bandwidth), you can choose a hot bundle to split."),(0,l.kt)("h4",{id:"step-2-compute-bundle-splitting-position-boundaries"},"Step 2: compute bundle splitting position boundaries"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"If you want to use the specified_positions_divide algorithm, you need to specify a splitting boundary.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"If you want to use other ",(0,l.kt)("a",{parentName:"p",href:"#bundle-splitting-algorithms"},"bundle splitting algorithms")," except for the specified_positions_divide algorithm, those algorithms will calculate the position automatically."))),(0,l.kt)("p",null,"Step 3: split bundles at the specific boundaries from step 2."),(0,l.kt)("p",null,"For how to split bundles manually, see TBD (the docs is WIP, stay tuned!)."))),(0,l.kt)("h3",{id:"bundle-splitting-algorithms"},"Bundle splitting algorithms"),(0,l.kt)("p",null,"Bundle splitting positions can be calculated using different bundle splitting algorithms."),(0,l.kt)("p",null,"Below is a brief summary of bundle splitting algorithms."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Bundle splitting algorithm"),(0,l.kt)("th",{parentName:"tr",align:null},"Definition"),(0,l.kt)("th",{parentName:"tr",align:null},"When to use"),(0,l.kt)("th",{parentName:"tr",align:null},"Available in  automatic or manual method?"),(0,l.kt)("th",{parentName:"tr",align:null},"Available version"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"range_equally_divide"),(0,l.kt)("td",{parentName:"tr",align:null},"Split a bundle into two parts with the same hash range size."),(0,l.kt)("td",{parentName:"tr",align:null},"This is the ",(0,l.kt)("strong",{parentName:"td"},"default")," bundle splitting algorithm. ",(0,l.kt)("br",null),(0,l.kt)("br",null)," Use when there are a large number of topics."),(0,l.kt)("td",{parentName:"tr",align:null},"- Automatic ",(0,l.kt)("br",null)," - Manual"),(0,l.kt)("td",{parentName:"tr",align:null},"Pulsar 1.7 and later versions")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"topic_count_equally_divide"),(0,l.kt)("td",{parentName:"tr",align:null},"Split a bundle into two parts with the same number of topics."),(0,l.kt)("td",{parentName:"tr",align:null},"Use when there are a small number of topics."),(0,l.kt)("td",{parentName:"tr",align:null},"- Automatic ",(0,l.kt)("br",null)," - Manual"),(0,l.kt)("td",{parentName:"tr",align:null},"Pulsar 2.6 and later versions")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"specified_positions_divide"),(0,l.kt)("td",{parentName:"tr",align:null},"Split a bundle into several parts by the specified positions."),(0,l.kt)("td",{parentName:"tr",align:null},"Use when the automatic bundle splitting is turned off, or a bundle is not split even if the automatic bundle splitting is turned on. ",(0,l.kt)("br",null),(0,l.kt)("br",null)," ",(0,l.kt)("strong",{parentName:"td"},"Note"),": Be cautious when using this algorithm. For example, if bundles are split into ",(0,l.kt)("strong",{parentName:"td"},"too many small parts"),", then these bundles could not be hit by the hash key. Currently, ",(0,l.kt)("strong",{parentName:"td"},"bundle compaction is not supported"),"."),(0,l.kt)("td",{parentName:"tr",align:null},"- Manual"),(0,l.kt)("td",{parentName:"tr",align:null},"Pulsar 2.11 and later versions")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flow_or_qps_equally_divide"),(0,l.kt)("td",{parentName:"tr",align:null},"Split a bundle into several parts based on message rate and throughput."),(0,l.kt)("td",{parentName:"tr",align:null},"Use when splitting bundles proportional to traffic."),(0,l.kt)("td",{parentName:"tr",align:null},"- Automatic ",(0,l.kt)("br",null)," - Manual"),(0,l.kt)("td",{parentName:"tr",align:null},"Pulsar 3.0 and later versions")))),(0,l.kt)("h4",{id:"range_equally_divide"},"range_equally_divide"),(0,l.kt)("p",null,"range_equally_divide splits a bundle into two parts with the same hash range size."),(0,l.kt)("p",null,"For example, if the target bundle to split is (0x00000000, 0x80000000), then the bundle split boundary is ","[0x40000000]","."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"concept of range_equally_divide",src:a(83692).Z,width:"936",height:"636"})),(0,l.kt)("h4",{id:"topic_count_equally_divide"},"topic_count_equally_divide"),(0,l.kt)("p",null,"topic_count_equally_divide splits a bundle into two parts with the same number of topics."),(0,l.kt)("p",null,"For example, if there are 6 topics in the target bundle [0x00000000, 0x80000000), then you can set the bundle splitting boundary at 0x50000000 to make the left and right sides of the number of topics the same. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"hash(topic1) = 0x10000000\nhash(topic2) = 0x20000000\nhash(topic3) = 0x35000000\nhash(topic4) = 0x65000000\nhash(topic5) = 0x70000000\nhash(topic6) = 0x75000000\n")),(0,l.kt)("p",null,"That is, the target bundle to split is [0x00000000, 0x80000000), and the bundle split boundary is ","[0x50000000]","."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"concept of topic_count_equally_divide",src:a(70342).Z,width:"936",height:"732"})),(0,l.kt)("p",null,"For implementation details, see ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/apache/pulsar/pull/6241"},"PR-6241: support evenly distribute topics count when splitting bundles"),"."),(0,l.kt)("h4",{id:"specified_positions_divide"},"specified_positions_divide"),(0,l.kt)("p",null,"specified_positions_divide splits bundles into several parts by specified positions."),(0,l.kt)("p",null,"For example, if you have 2 large topics and there are on the same bundle. Topic1 is at 0x30000000, topic2 is at 0x35000000, and the bundle range is [0x00000000, 0x40000000), then you can set the bundle split boundary as 0x33000000."),(0,l.kt)("p",null,"For implementation details, see ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/apache/pulsar/issues/13761"},"PIP-143: support split bundle by specified boundaries"),"."),(0,l.kt)("h4",{id:"flow_or_qps_equally_divide"},"flow_or_qps_equally_divide"),(0,l.kt)("p",null,"flow_or_qps_equally_divide splits bundles into several parts based on ",(0,l.kt)("strong",{parentName:"p"},"message rate")," (controlled by ",(0,l.kt)("inlineCode",{parentName:"p"},"loadBalancerNamespaceBundleMaxMsgRate"),") or ",(0,l.kt)("strong",{parentName:"p"},"message throughput")," (controlled by ",(0,l.kt)("inlineCode",{parentName:"p"},"loadBalancerNamespaceBundleMaxBandwidthMbytes"),"). The split position is determined by reaching the threshold of either message rate or message throughput. "),(0,l.kt)("p",null,"For example, suppose that you have 6 topics on a bundle range ","[0x00000000 to 0x80000000]"," as below. "),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Topic name"),(0,l.kt)("th",{parentName:"tr",align:null},"Hash code"),(0,l.kt)("th",{parentName:"tr",align:null},"Message rate"),(0,l.kt)("th",{parentName:"tr",align:null},"Message throughput"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"t1"),(0,l.kt)("td",{parentName:"tr",align:null},"0x10000000"),(0,l.kt)("td",{parentName:"tr",align:null},"100/s"),(0,l.kt)("td",{parentName:"tr",align:null},"10M/s")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"t2"),(0,l.kt)("td",{parentName:"tr",align:null},"0x15000000"),(0,l.kt)("td",{parentName:"tr",align:null},"200/s"),(0,l.kt)("td",{parentName:"tr",align:null},"20M/s")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"t3"),(0,l.kt)("td",{parentName:"tr",align:null},"0x24000000"),(0,l.kt)("td",{parentName:"tr",align:null},"300/s"),(0,l.kt)("td",{parentName:"tr",align:null},"30M/s")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"t4"),(0,l.kt)("td",{parentName:"tr",align:null},"0x39000000"),(0,l.kt)("td",{parentName:"tr",align:null},"400/s"),(0,l.kt)("td",{parentName:"tr",align:null},"40M/s")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"t5"),(0,l.kt)("td",{parentName:"tr",align:null},"0x58000000"),(0,l.kt)("td",{parentName:"tr",align:null},"500/s"),(0,l.kt)("td",{parentName:"tr",align:null},"50M/s")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"t6"),(0,l.kt)("td",{parentName:"tr",align:null},"0x76000000"),(0,l.kt)("td",{parentName:"tr",align:null},"600/s"),(0,l.kt)("td",{parentName:"tr",align:null},"60M/s")))),(0,l.kt)("p",null,"The split position varies depending on the values of message rate or message throughput."),(0,l.kt)("h5",{id:"case-1-split-position-is-determined-by-message-rate-as-it-reaches-the-threshold-earlier"},"Case 1: split position is determined by message rate as it reaches the threshold earlier"),(0,l.kt)("p",null,"If you set"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"loadBalancerNamespaceBundleMaxMsgRate"),"=450/s"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"loadBalancerNamespaceBundleMaxBandwidthMbytes"),"=200M/s"),(0,l.kt)("p",null,"Since "),(0,l.kt)("p",null,"100/s+ 200/s < 450/s"),(0,l.kt)("p",null,"100/s+ 200/s + 300/s > 450/s "),(0,l.kt)("p",null,"So the split boundary is between t2 and t3, that is:"),(0,l.kt)("p",null,"splitStartPosition = 0x15000000"),(0,l.kt)("p",null,"splitEndPosition = 0x24000000"),(0,l.kt)("p",null,"splitPosition = (0x15000000 + 0x24000000) / 2 = 0x19500000"),(0,l.kt)("p",null,"Note that the ",(0,l.kt)("strong",{parentName:"p"},"bundle split will be continued")," as below:"),(0,l.kt)("p",null,"------ 2nd bundle splitting ------"),(0,l.kt)("p",null,"Since "),(0,l.kt)("p",null,"300/s \uff1c 450/s"),(0,l.kt)("p",null,"300/s + 400/s > 450/s"),(0,l.kt)("p",null,"So the split boundary is between t3 and t4, that is"),(0,l.kt)("p",null,"splitStartPosition = 0x24000000"),(0,l.kt)("p",null,"splitEndPosition = 0x39000000"),(0,l.kt)("p",null,"splitPosition = 31500000 = (0x24000000 + 0x39000000) / 2"),(0,l.kt)("p",null,"------ 3rd bundle splitting ------"),(0,l.kt)("p",null,"Since "),(0,l.kt)("p",null,"400/s \uff1c 450/s"),(0,l.kt)("p",null,"400/s + 500/s > 450/s"),(0,l.kt)("p",null,"So the split boundary is between t4 and t5, that is"),(0,l.kt)("p",null,"splitStartPosition = 0x39000000"),(0,l.kt)("p",null,"splitEndPosition = 0x58000000"),(0,l.kt)("p",null,"splitPosition = 48500000 = (0x39000000 + 0x58000000) /2"),(0,l.kt)("p",null,"------ 4th bundle splitting ------"),(0,l.kt)("p",null,"Since"),(0,l.kt)("p",null,"500/s > 450/s"),(0,l.kt)("p",null,"600/s > 450/s"),(0,l.kt)("p",null,"So the split boundary is between t5 and t6, that is"),(0,l.kt)("p",null,"splitStartPosition = 0x58000000"),(0,l.kt)("p",null,"splitEndPosition = 0x76000000"),(0,l.kt)("p",null,"splitPosition = 67000000 = (0x58000000 + 0x76000000) / 2"),(0,l.kt)("h4",{id:"case-2-split-position-is-determined-by-message-throughput-as-it-reaches-the-threshold-earlier"},"Case 2: split position is determined by message throughput as it reaches the threshold earlier"),(0,l.kt)("p",null,"If you set"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"loadBalancerNamespaceBundleMaxMsgRate"),"=1900/s"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"loadBalancerNamespaceBundleMaxBandwidthMbytes"),"=90M/s"),(0,l.kt)("p",null,"Since "),(0,l.kt)("p",null,"10M/s+ 20M/s + 30M/s < 90M/s"),(0,l.kt)("p",null,"10M/s+ 20M/s + 30M/s + 40M/s > 90M/s "),(0,l.kt)("p",null,"So the split boundary is between t3 and t4, that is:"),(0,l.kt)("p",null,"splitStartPosition = 0x24000000"),(0,l.kt)("p",null,"splitEndPosition = 0x39000000"),(0,l.kt)("p",null,"splitPosition = (0x24000000 + 0x39000000) / 2 = 0x31500000"),(0,l.kt)("p",null,"Note that the ",(0,l.kt)("strong",{parentName:"p"},"bundle split will be continued"),": "),(0,l.kt)("p",null,"------ 2nd bundle splitting ------"),(0,l.kt)("p",null,"Since "),(0,l.kt)("p",null,"40 + 50 \u2264 90"),(0,l.kt)("p",null,"40 +50 + 60 > 90"),(0,l.kt)("p",null,"So the split boundary is between t5 and t6, that is:"),(0,l.kt)("p",null,"splitStartPosition = 0x58000000"),(0,l.kt)("p",null,"splitEndPosition = 0x76000000"),(0,l.kt)("p",null,"splitPosition = (0x58000000 + 0x0x76000000) / 2 = 0x67000000"),(0,l.kt)("h4",{id:"case-3-split-position-is-determined-by-both-message-rate-and-message-throughput-as-they-reach-the-thresholds-at-the-same-time"},"Case 3: split position is determined by both message rate and message throughput as they reach the thresholds at the same time"),(0,l.kt)("p",null,"If you set"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"loadBalancerNamespaceBundleMaxMsgRate"),"=1100"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"loadBalancerNamespaceBundleMaxBandwidthMbytes"),"=110"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"From the ",(0,l.kt)("strong",{parentName:"p"},"message rate")," side:"),(0,l.kt)("p",{parentName:"li"},"  Since "),(0,l.kt)("p",{parentName:"li"},"  100/s+ 200/s + 300/s + 400/s < 1100/s "),(0,l.kt)("p",{parentName:"li"},"  100/s+ 200/s + 300/s + 400/s + 500/s > 1100/s"),(0,l.kt)("p",{parentName:"li"},"  So the split boundary is between t4 and t5, that is:"),(0,l.kt)("p",{parentName:"li"},"  splitStartPosition = 0x39000000"),(0,l.kt)("p",{parentName:"li"},"  splitEndPosition = 0x58000000"),(0,l.kt)("p",{parentName:"li"},"  splitPosition = (0x39000000 + 0x58000000) / 2 = 0x48500000")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"From the ",(0,l.kt)("strong",{parentName:"p"},"message throughput")," side:"),(0,l.kt)("p",{parentName:"li"},"  Since "),(0,l.kt)("p",{parentName:"li"},"  10M/s+ 20M/s + 30M/s + 40M/s < 110M/s "),(0,l.kt)("p",{parentName:"li"},"  0M/s+ 20M/s + 30M/s + 40M/s + 50M/s > 110M/s"),(0,l.kt)("p",{parentName:"li"},"  So the split boundary is between t4 and t5, that is:"),(0,l.kt)("p",{parentName:"li"},"  splitStartPosition = 0x39000000"),(0,l.kt)("p",{parentName:"li"},"  splitEndPosition = 0x58000000"),(0,l.kt)("p",{parentName:"li"},"  splitPosition = (0x39000000 + 0x58000000) / 2 = 0x48500000"))),(0,l.kt)("p",null,"In summary, the split position is 0x48500000."),(0,l.kt)("p",null,"For implementation details, see ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/apache/pulsar/issues/16782"},"PIP-169: support split bundle by flow or QPS"),"."),(0,l.kt)("h2",{id:"bundle-unloading"},"Bundle unloading"),(0,l.kt)("p",null,"Bundle unloading (shedding) refers to the process of closing bundles (topics), releasing ownership, and reassigning bundles (topics) to a less-loaded broker from overloaded brokers, based on load conditions. "),(0,l.kt)("p",null,"Bundle unloading balances the workload across brokers and optimizes resource utilization in the cluster. For example, when a Pulsar cluster experiences changing workloads or scaling events (e.g., adding or removing brokers), bundle unloading ensures that the partitions are evenly distributed and no broker becomes overloaded. "),(0,l.kt)("p",null,"You can unload bundles in the following ways:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Automatic: enable Pulsar's automatic bundle unloading process when a broker is overloaded.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Manual: trigger bundle splitting manually, to unload a bundle from one broker to another broker within a Pulsar cluster. "))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Bundle unloading methods"),(0,l.kt)("th",{parentName:"tr",align:null},"Definition"),(0,l.kt)("th",{parentName:"tr",align:null},"When to use"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Automatic"),(0,l.kt)("td",{parentName:"tr",align:null},"When the load balancer recognizes a particular broker is overloaded, it forcefully unloads some bundles' traffic from the overloaded broker, so that the unloaded bundles (topics) can be reassigned to less-loaded brokers by the assignment process."),(0,l.kt)("td",{parentName:"tr",align:null},"Use when there is fluctuating traffic that varies over time.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Manual"),(0,l.kt)("td",{parentName:"tr",align:null},"You can manually trigger bundle unloading at any time."),(0,l.kt)("td",{parentName:"tr",align:null},"Manual bundle unloading serves as a ",(0,l.kt)("strong",{parentName:"td"},"supplementary")," approach to automatic bundle unloading. ",(0,l.kt)("br",null),(0,l.kt)("br",null),"If the automatic unloading does not kick in (e.g., due to misconfiguration), you can trigger manual unloading to mitigate the load-imbalance issue. To avoid manual unload operations, you need to correctly tune load balance configs according to the cluster's traffic.")))),(0,l.kt)("h3",{id:"workflow-3"},"Workflow"),(0,l.kt)("p",null,"Below is the workflow for unloading bundles automatically or manually."),(0,l.kt)(r.Z,{groupId:"bundle-unloading-workflow",defaultValue:"Automatic bundle unloading",values:[{label:"Automatic bundle unloading",value:"Automatic bundle unloading"},{label:"Manual bundle unloading",value:"Manual bundle unloading"}],mdxType:"Tabs"},(0,l.kt)(s.Z,{value:"Automatic bundle unloading",mdxType:"TabItem"},(0,l.kt)("h4",{id:"step-1-find-target-brokers"},"Step 1: find target brokers"),(0,l.kt)("p",null,"With the broker load information collected from all brokers, the leader broker computes the resource usage of each broker based on the ",(0,l.kt)("a",{parentName:"p",href:"tbd"},"bundle unloading strategies"),"."),(0,l.kt)("h4",{id:"step-2-unload-bundles"},"Step 2: unload bundles"),(0,l.kt)("p",null,"If the lead broker finds a broker is overloaded, it will calculate the overloaded bundles, ask the overloaded broker to unload some bundles of topics, remove the target bundles' ownerships, and close the topic sessions and the client connections. "),(0,l.kt)("h4",{id:"step-3-assign-new-owners"},"Step 3: assign new owners"),(0,l.kt)("p",null,"The unloaded bundles are assigned to less loaded brokers, and the clients connect to them. "),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"For the modular load balancer, bundles will be post-assigned to available brokers when clients send lookup requests.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"For the extensible load balancer, bundles will be pre-assigned to available brokers when unloading."))),(0,l.kt)("p",null,"When unloading happens, the client experiences a small latency blip while the topic is reassigned. "),(0,l.kt)("p",null,"For how to unload bundles automatically, see TBD (the docs is WIP, stay tuned!).")),(0,l.kt)(s.Z,{value:"Manual bundle unloading",mdxType:"TabItem"},(0,l.kt)("h4",{id:"step-1-find-target-bundles-2"},"Step 1: find target bundles"),(0,l.kt)("p",null,"Based on the broker resource usage (for example, CPU, network, and memory usage), you can choose hot bundles to unload."),(0,l.kt)("h4",{id:"step-2-unload-hot-bundles"},"Step 2: unload hot bundles"),(0,l.kt)("p",null,"Unload hot bundles to available brokers. Target bundles' ownerships will be transferred, and topic connections will be closed."),(0,l.kt)("p",null,"For how to unload bundles manually, see TBD (the docs is WIP, stay tuned!)."))),(0,l.kt)("h3",{id:"bundle-unloading-strategies"},"Bundle unloading strategies"),(0,l.kt)("p",null,"You can choose different bundle unloading strategies based on your needs. "),(0,l.kt)("p",null,"Below is a quick summary of bundle unloading strategies, which are ",(0,l.kt)("strong",{parentName:"p"},"only applicable")," for unloading bundles",(0,l.kt)("strong",{parentName:"p"}," automatically"),"."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Bundle unloading strategy"),(0,l.kt)("th",{parentName:"tr",align:null},"Definition"),(0,l.kt)("th",{parentName:"tr",align:null},"When to use"),(0,l.kt)("th",{parentName:"tr",align:null},"Available version"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"OverloadShedder"),(0,l.kt)("td",{parentName:"tr",align:null},"Unload bundles on brokers if a ",(0,l.kt)("strong",{parentName:"td"},"broker's maximum resource usage")," exceeds the configured threshold."),(0,l.kt)("td",{parentName:"tr",align:null},"Use when you want to set broker usage below a threshold."),(0,l.kt)("td",{parentName:"tr",align:null},"Pulsar 1.18 and later versions.",(0,l.kt)("br",null),(0,l.kt)("br",null)," This strategy is ",(0,l.kt)("strong",{parentName:"td"},"only available")," in the ",(0,l.kt)("strong",{parentName:"td"},"modular")," load balancer.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ThresholdShedder"),(0,l.kt)("td",{parentName:"tr",align:null},"Unload bundles if a broker's average usage is greater than the",(0,l.kt)("strong",{parentName:"td"}," cluster average usage")," plus ",(0,l.kt)("strong",{parentName:"td"},"configured threshold"),"."),(0,l.kt)("td",{parentName:"tr",align:null},"Use when you want to evenly spread loads across all brokers base on cluster average usage."),(0,l.kt)("td",{parentName:"tr",align:null},"Pulsar 2.6 and later versions.",(0,l.kt)("br",null),(0,l.kt)("br",null)," This strategy is ",(0,l.kt)("strong",{parentName:"td"},"only available")," in the ",(0,l.kt)("strong",{parentName:"td"},"modular")," load balancer.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"UniformLoadShedder"),(0,l.kt)("td",{parentName:"tr",align:null},"Distribute load uniformly across all brokers, based on ",(0,l.kt)("strong",{parentName:"td"},"minimal")," and ",(0,l.kt)("strong",{parentName:"td"},"maximum")," load."),(0,l.kt)("td",{parentName:"tr",align:null},"Use when you want to compare the minimal and maximum loaded brokers."),(0,l.kt)("td",{parentName:"tr",align:null},"Pulsar 2.10.0 and later versions.",(0,l.kt)("br",null),(0,l.kt)("br",null)," This strategy is ",(0,l.kt)("strong",{parentName:"td"},"only available")," in the ",(0,l.kt)("strong",{parentName:"td"},"modular")," load balancer.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"TransferShedder"),(0,l.kt)("td",{parentName:"tr",align:null},"Unload bundles from the ",(0,l.kt)("strong",{parentName:"td"},"highest")," load brokers to the ",(0,l.kt)("strong",{parentName:"td"},"lowest")," load brokers until the standard deviation of the broker load distribution is below the configured threshold."),(0,l.kt)("td",{parentName:"tr",align:null},"This is the ",(0,l.kt)("strong",{parentName:"td"},"default")," strategy for the ",(0,l.kt)("strong",{parentName:"td"},"extensible")," load balancer. ",(0,l.kt)("br",null),(0,l.kt)("br",null),"It pre-assigns destination brokers when unloading."),(0,l.kt)("td",{parentName:"tr",align:null},"Pulsar 3.0 and later versions.",(0,l.kt)("br",null),(0,l.kt)("br",null),"This strategy is ",(0,l.kt)("strong",{parentName:"td"},"only available")," in the ",(0,l.kt)("strong",{parentName:"td"},"extensible")," load balancer.")))),(0,l.kt)("h4",{id:"overloadshedder"},"OverloadShedder"),(0,l.kt)("p",null,"OverloadShedder strategy sheds bundles on brokers if a broker's maximum resource usage exceeds the configured threshold (",(0,l.kt)("inlineCode",{parentName:"p"},"loadBalancerBrokerOverloadedThresholdPercentage"),")."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Concept of OverloadShedder",src:a(5993).Z,width:"1790",height:"625"})," "),(0,l.kt)("p",null,"If a broker is overloaded and has at least two bundles assigned. At the same time, if that broker has at least one bundle that has not been unloaded, then this (these) bundle(s) will be unloaded. Bundles with higher message throughput will be unloaded before those with lower message throughput."),(0,l.kt)("p",null,"The determination of when a broker is overloaded is based on the threshold of CPU, network, and memory usage. Whenever either of those metrics reaches the threshold (the ",(0,l.kt)("strong",{parentName:"p"},"default value")," is 85%), the system triggers the bundle unloading."),(0,l.kt)("h4",{id:"thresholdshedder"},"ThresholdShedder"),(0,l.kt)("p",null,"ThresholdShedder strategy sheds the bundles if a ",(0,l.kt)("strong",{parentName:"p"},"broker's average usage")," is greater than the ",(0,l.kt)("strong",{parentName:"p"},"cluster average usage")," plus ",(0,l.kt)("strong",{parentName:"p"},"configured threshold"),". "),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Concept of ThresholdShedder",src:a(33208).Z,width:"1776",height:"683"})," "),(0,l.kt)("h5",{id:"workflow-4"},"Workflow"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"ThresholdShedder first computes the average resource usage of brokers for the whole cluster (that is, ",(0,l.kt)("strong",{parentName:"p"},"cluster average usage"),"). "),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The resource usage for each broker is calculated using the method ",(0,l.kt)("inlineCode",{parentName:"p"},"LocalBrokerData#getMaxResourceUsageWithWeight"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Historical observations are included in the running average based on the broker's setting for ",(0,l.kt)("inlineCode",{parentName:"p"},"loadBalancerHistoryResourcePercentage"),". ")))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"ThresholdShedder compares each broker's average resource usage (based on current and historical resource usage) to the cluster average usage:"),(0,l.kt)("p",{parentName:"li"},"a. If a ",(0,l.kt)("strong",{parentName:"p"},"broker's resource usage")," is greater than the ",(0,l.kt)("strong",{parentName:"p"},"cluster average usage")," plus the ",(0,l.kt)("strong",{parentName:"p"},"configured threshold"),", ThresholdShedder proposes removing enough bundles to bring the unloaded broker 5% below the ",(0,l.kt)("strong",{parentName:"p"},"cluster average usage"),". ",(0,l.kt)("strong",{parentName:"p"},"Note")," that recently unloaded bundles are ",(0,l.kt)("strong",{parentName:"p"},"not unloaded again"),"."),(0,l.kt)("p",{parentName:"li"},"b. If a ",(0,l.kt)("strong",{parentName:"p"},"broker's resource usage")," is smaller than the ",(0,l.kt)("strong",{parentName:"p"},"cluster average usage"),", or smaller than the ",(0,l.kt)("strong",{parentName:"p"},"cluster average usage")," plus the ",(0,l.kt)("strong",{parentName:"p"},"configured threshold"),", no bundle will be unloaded."))),(0,l.kt)("p",null,"For example, assume that you have 3 brokers and each broker\u2019s average usage is as below."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Broker name"),(0,l.kt)("th",{parentName:"tr",align:null},"Broker's average usage"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"broker1"),(0,l.kt)("td",{parentName:"tr",align:null},"40%")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"broker2"),(0,l.kt)("td",{parentName:"tr",align:null},"10%")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"broker3"),(0,l.kt)("td",{parentName:"tr",align:null},"10%")))),(0,l.kt)("p",null,"So the cluster average usage is 20% = (40% + 10% + 10%) / 3. "),(0,l.kt)("p",null,"If you set the threshold (",(0,l.kt)("inlineCode",{parentName:"p"},"loadBalancerBrokerThresholdShedderPercentage"),") to 10%,\nthen only broker1's certain bundles get unloaded, because the broker1's resource usage (40%) is greater than the sum (30%) of the ",(0,l.kt)("strong",{parentName:"p"},"cluster average usage")," (20%) plus ",(0,l.kt)("strong",{parentName:"p"},"configured threshold")," (10%)."),(0,l.kt)("h4",{id:"uniformloadshedder"},"UniformLoadShedder"),(0,l.kt)("p",null,"UniformLoadShedder strategy distributes load uniformly across all brokers. It checks the load difference between the broker with the ",(0,l.kt)("strong",{parentName:"p"},"highest")," load and the broker with the ",(0,l.kt)("strong",{parentName:"p"},"lowest")," load. If the difference is higher than configured thresholds, either ",(0,l.kt)("strong",{parentName:"p"},"message rate")," (controlled by)",(0,l.kt)("inlineCode",{parentName:"p"},"loadBalancerMsgRateDifferenceShedderThreshold")," or ",(0,l.kt)("strong",{parentName:"p"},"throughput")," (controlled by ",(0,l.kt)("inlineCode",{parentName:"p"},"loadBalancerMsgThroughputMultiplierDifferenceShedderThreshold"),"), then it finds out bundles that can be unloaded to distribute traffic evenly across all brokers."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Concept of UniformLoadShedder",src:a(14358).Z,width:"1786",height:"635"})," "),(0,l.kt)("p",null,"For implementation details, see ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/apache/pulsar/pull/12902"},"PR-12902: add uniform load shedder strategy to distribute traffic uniformly across brokers"),"."),(0,l.kt)("h4",{id:"transfershedder"},"TransferShedder"),(0,l.kt)("p",null,"TransferShedder strategy unloads bundles from the ",(0,l.kt)("strong",{parentName:"p"},"highest")," load brokers to the ",(0,l.kt)("strong",{parentName:"p"},"lowest")," load brokers until all of the following are true:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The standard deviation of the broker load distribution is below the configured threshold (loadBalancerBrokerLoadTargetStd, default value is 0.25).")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"There are no significant underloaded brokers."),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"No broker receives 0 traffic.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"No broker's load < avgLoad * min(0.5, loadBalancerBrokerLoadTargetStd / 2)")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"There is no significant overloaded brokers"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"No broker\u2019s load > loadBalancerBrokerOverloadedThresholdPercentage && load > avgLoad + loadBalancerBrokerLoadTargetStd")))),(0,l.kt)("p",null,"Pulsar introduced TransferShedder to utilize the bundle transfer protocol from the extensible load balancer. With this bundle transfer protocol, the bundle ownership can be gracefully transferred from the source broker to the destination broker. This means that TransferShedder pre-assigns the destination brokers at the unloading time instead of client lookups. Hence, after unloading, clients can bypass the assignment process as the new owner is already assigned."),(0,l.kt)("p",null,"For implementation details, see ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/apache/pulsar/issues/18215"},"PIP-220: TransferShedder"),"."),(0,l.kt)("h2",{id:"related-topics"},"Related topics"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"To get a comprehensive understanding and discover the key insights, see ",(0,l.kt)("a",{parentName:"p",href:"/docs/3.1.x/concepts-broker-load-balancing-overview"},"Broker load balancing | Overview"),". ")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"To discover different usage scenarios, see ",(0,l.kt)("a",{parentName:"p",href:"./concepts-broker-load-balancing-use-cases.md"},"Broker load balancing | Use cases"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"To explore functionalities, see ",(0,l.kt)("a",{parentName:"p",href:"/docs/3.1.x/concepts-broker-load-balancing-features"},"Broker load balancing | Features"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"To understand advantages, see ",(0,l.kt)("a",{parentName:"p",href:"/docs/3.1.x/concepts-broker-load-balancing-benefits"},"Broker load balancing | Benefits"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"To review various versions of broker load balancers, see ",(0,l.kt)("a",{parentName:"p",href:"/docs/3.1.x/concepts-broker-load-balancing-types"},"Broker load balancing | Types"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"To get up quickly, see ",(0,l.kt)("a",{parentName:"p",href:"/docs/3.1.x/concepts-broker-load-balancing-quick-start"},"Broker load balancing | Quick start"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"To migrate one broker load balancer type to another, see ",(0,l.kt)("a",{parentName:"p",href:"/docs/3.1.x/concepts-broker-load-balancing-migration"},"Broker load balancing | Migration"),"."))))}b.isMDXComponent=!0},84865:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/broker-load-balancing-1-bbb79076076734e16152ec6c68fdfe2a.png"},68933:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/broker-load-balancing-2-64cb741da795712329dd766cc1c53d21.png"},2681:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/broker-load-balancing-3-b62cf1287cba8a48e4d627269475e7e4.png"},22451:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/broker-load-balancing-4-84486092a1d2e3a13218e8e776796d82.png"},83692:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/broker-load-balancing-5-9aaca4795accfd547b0ba5383727b31c.png"},70342:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/broker-load-balancing-6-c37e5496244f826fdfbe895870939233.png"},5993:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/shedding-strategy-overloadshedder-82646099fbc5728e78d7d4d3eb151e18.svg"},33208:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/shedding-strategy-thresholdshedder-69bc0835a1752056e0cc058d6c7c72f1.svg"},14358:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/shedding-strategy-uniformLoadshedder-a521b90620882e7ce650d4ee6d0561bc.svg"}}]);